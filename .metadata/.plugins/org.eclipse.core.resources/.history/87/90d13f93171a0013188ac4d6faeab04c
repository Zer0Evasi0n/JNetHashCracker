import java.math.BigInteger;
import java.util.ArrayList;

public class JobManagement implements Runnable {
	@SuppressWarnings("rawtypes")
	public static volatile ArrayList incomplete = new ArrayList();
	@SuppressWarnings("rawtypes")
	public static volatile ArrayList requests = new ArrayList();
	@SuppressWarnings("rawtypes")
	public static ArrayList toRemove = new ArrayList();
	public static BigInteger startCrackNumber = BigInteger.valueOf(0);
	private Client current;
	//public static Client c;
	private float clientRate;
	private float totalRate;
	private long range;
	private BigInteger[] storage = new BigInteger[2];
	private boolean cracking = false;
	public JobManagement() {

	}
	@SuppressWarnings("unchecked")
	public void run() {
		while (true) {
			try {
				double clientPercent;
				if (cracking != Startup.cracking) {
					if (!Startup.cracking) {
						requests.clear();
						incomplete.clear();
					}
					cracking = Startup.cracking;
				}
				Thread.sleep(25);
				if (requests.size() != 0) {
					for (Object s : requests) {
						toRemove.add(s);
						current = (Client)s;
						clientRate = current.clientHashRate;
						totalRate = Startup.getHashRate();
						double connectedNum = Startup.clients.size();
						if (incomplete.size() == 0) {
							if (current.average != -1) {
								clientRate = current.average;
							}
							if(clientRate == 0 || totalRate == 0) {
								totalRate = (float) (2000 * connectedNum);
								clientRate = 2000;
							}
							
							double shouldRate = (totalRate / connectedNum);
							clientPercent = clientRate / shouldRate;
							range = (long) (clientPercent * 10250000);
							System.out.println("========================");
							System.out.println("Total Rate: " + totalRate);
							System.out.println(connectedNum + " Clients");
							System.out.println("Should Be: " + shouldRate);
							//System.out.println("Total :" + totalRate);
							System.out.println("Client: " + clientRate);
							//System.out.println("Client Actually: " + clientPercent * 100 + "%");
							System.out.println("Range: " + range);
							current.bounds[0] = startCrackNumber;
							current.bounds[1] = startCrackNumber.add(BigInteger.valueOf(range));
							startCrackNumber = current.bounds[1];
							current.hasBlock = true;
						} else {
							storage = (BigInteger[]) incomplete.get(0);
							current.bounds[0] = storage[0];
							current.bounds[1] = storage[1];
							current.hasBlock = true;
							incomplete.remove(0);
							System.out.println("Recycled rejected block with range of " + storage[1].subtract(storage[0]));
						}
					}
					for (Object s : toRemove) {
						requests.remove(s);
					}
					toRemove.clear();
				}
			} catch (Exception e) { e.printStackTrace(); }
		}
	}
	
	public void resetStart() {
		startCrackNumber = BigInteger.valueOf(0);
	}
}
